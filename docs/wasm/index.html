<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran.js: Single cell RNA-seq analysis in Javascript</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran.js
   </div>
   <div id="projectbrief">Compiling scran&#39;s C++ library to WebAssembly</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Single cell RNA-seq analysis in Javascript </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__github_workspace_README"></a> </p><h1>Overview</h1>
<p >This repository contains <b>scran.js</b>, a Javascript library for single-cell RNA-seq (scRNA-seq) analysis in the browser. The various calculations are performed directly by the client, allowing us to take advantage of the ubiquity of the browser as a standalone analysis platform. Users can then directly analyze their data without needing to manage any dependencies or pay for access to a backend. <b>scran.js</b> is heavily inspired by the <a href="https://bioconductor.org/packages/scran"><b>scran</b> R package</a> and contains most of its related methods. Indeed, much of the implementation in this repository is taken directly from <b>scran</b> and its related R packages.</p>
<h1>Analysis overview</h1>
<p ><b>scran.js</b> implements key steps in a typical scRNA-seq analysis:</p>
<ul>
<li>Quality control (QC) to remove low-quality cells. This is done based on detection of outliers on QC metrics like the number of detected genes.</li>
<li>Normalization and log-transformation, to remove biases and mitigate the mean-variance trend. We use scaling normalization with size factors defined from the library size for each cell.</li>
<li>Feature selection to identify highly variable genes. This is based on residuals from a trend fitted to the means and variances of the log-normalized data for each gene.</li>
<li>Principal components analysis (PCA) on the highly variable genes, to compress and denoise the data. We use an approximate method to quickly obtain the top few PCs.</li>
<li>Clustering on the cells using the top PCs. This can either use k-means or multi-level community detection (a.k.a., "Louvain clustering") on a shared nearest neighbor graph.</li>
<li>Dimensionality reduction with t-stochastic neighbor embedding (t-SNE), again using the top PCs.</li>
<li>Marker detection using a variety of effect sizes such as Cohen's d and the area under the curve (AUC).</li>
<li>Cell type annotation with a port of the <a href="https://bioconductor.org/packages/SingleR"><b>SingleR</b></a> algorithm.</li>
<li>Batch correction via the mutual nearest neighbors method.</li>
</ul>
<p >The theory behind these methods is described in more detail in the <a href="https://bioconductor.org/books/release/OSCA/"><b>Orchestrating Single Cell Analysis with Bioconductor</b></a> book. All steps are implemented in C++ and compiled to WebAssembly for near-native performance - see the developer notes for details.</p>
<h1>Quick start</h1>
<p ><b>scran.js</b> is available as an <a href="https://www.npmjs.com/package/scran.js">npm package</a>, so installation can be performed via the usual procedure:</p>
<div class="fragment"><div class="line">npm install scran.js</div>
</div><!-- fragment --><p >Then you can import and initialize the library using the standard ES6 notation. Before any actual analysis steps are performed, the <code>initialize()</code> function must be run and its promise resolved; we suggest using a top-level <code>await</code> for convenience.</p>
<div class="fragment"><div class="line">import * as scran from &quot;scran.js&quot;;</div>
<div class="line">await scran.initialize({ numberOfThreads: 4 }); // for old Node versions, set localFile: true</div>
</div><!-- fragment --><p >After that, you can run the remaining steps synchronously - for example, using the Node.js API:</p>
<div class="fragment"><div class="line">// Reading in the count matrix.</div>
<div class="line">import * as fs from &quot;fs&quot;;</div>
<div class="line">let buffer = fs.readFileSync(&quot;matrix.mtx.gz&quot;);</div>
<div class="line">let mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);</div>
</div><!-- fragment --><p >Reference documentation for the Javascript API is available <a href="https://jkanche.github.io/scran.js">here</a>.</p>
<h1>Basic analyses</h1>
<p >The code chunk below implements a basic analysis, starting from count matrix loading and terminating at the markers for each cluster. This uses the Node.js API to read in one of our example <a href="https://github.com/jkanche/random-test-files">Matrix Market files</a>, but the same approach can be used on the buffer created from a <code>File</code> input in the browser.</p>
<div class="fragment"><div class="line">// Reading in the count matrix.</div>
<div class="line">import * as fs from &quot;fs&quot;;</div>
<div class="line">let buffer = fs.readFileSync(&quot;matrix.mtx.gz&quot;);</div>
<div class="line">let mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);</div>
<div class="line"> </div>
<div class="line">// Performing QC.</div>
<div class="line">let qc_metrics = scran.computePerCellQCMetrics(mat, [ /* specify mito subset here */ ]);</div>
<div class="line">let qc_thresholds = scran.computePerCellQCThresholds(qc_metrics);</div>
<div class="line">let filtered = scran.filterCells(mat, qc_thresholds.discardOverall());</div>
<div class="line"> </div>
<div class="line">// Log-normalizing.</div>
<div class="line">let normalized = scran.logNormCounts(filtered);</div>
<div class="line"> </div>
<div class="line">// Modelling per-gene variance and selecting top HVGs. </div>
<div class="line">let varmodel = scran.modelGeneVar(normalized);</div>
<div class="line">let hvgs = scran.chooseHVGs(varmodel, { number: 4000 });</div>
<div class="line"> </div>
<div class="line">// Performing the PCA.</div>
<div class="line">let pcs = scran.runPCA(normalized, { features: hvgs });</div>
<div class="line"> </div>
<div class="line">// Building the neighbor search index on the PCs.</div>
<div class="line">let index = scran.buildNeighborSearchIndex(pcs);</div>
<div class="line"> </div>
<div class="line">// Performing the clustering. </div>
<div class="line">let cluster_graph = scran.buildSNNGraph(index, { neighbors: 10 });</div>
<div class="line">let clustering = scran.clusterSNNGraph(cluster_graph);</div>
<div class="line"> </div>
<div class="line">// Performing the t-SNE and UMAP.</div>
<div class="line">let tsne_status = scran.initializeTSNE(index);</div>
<div class="line">let tsne_res = scran.runTSNE(tsne_status);</div>
<div class="line"> </div>
<div class="line">let umap_status = scran.initializeUMAP(index);</div>
<div class="line">let umap_res = scran.runUMAP(umap_status);</div>
<div class="line"> </div>
<div class="line">// Detecting some markers.</div>
<div class="line">let markers = scran.scoreMarkers(normalized, clustering.membership());</div>
</div><!-- fragment --><p >Note that the order of rows is permuted on input - see below for details.</p>
<h1>Further details</h1>
<h2>Permuting the row order</h2>
<p >Rows of the dataset are permuted by <code>initializeSparseMatrix*()</code> functions to achieve a memory-efficient layout in <code>mat</code>. The permutation to restore the original row order can be obtained with:</p>
<div class="fragment"><div class="line">let perm1 = mat.permutation();</div>
</div><!-- fragment --><p >This can be used to permute the results of per-gene analyses like <code>modelGeneVar()</code> and <code>scoreMarkers()</code> to match the original row order. Alternatively, we can use:</p>
<div class="fragment"><div class="line">let perm2 = mat.permutation({ restore: false });</div>
</div><!-- fragment --><p >if we want to permute something in the original order to match the row order of <code>mat</code>.</p>
<h2>Memory management</h2>
<p >All custom classes returned by <b>scran.js</b> functions refer to allocations on the Wasm heap and are not subject to garbage collection by Javascript. If you intend to perform more <b>scran.js</b> operations after your analysis is complete, you will need to manually free existing objects to make space for new ones. We suggest using the pattern below to catch all objects and free them.</p>
<div class="fragment"><div class="line">var things = {};</div>
<div class="line">things.mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);</div>
<div class="line"> </div>
<div class="line">try {</div>
<div class="line">    /** some work here, possibly adding more objects to &#39;things&#39; **/</div>
<div class="line">} finally {</div>
<div class="line">    // Once the analysis is complete and results have been saved to file.</div>
<div class="line">    for (const [key, val] of Object.entries(things)) {</div>
<div class="line">        val.free();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Terminating workers</h2>
<p >On Node.js, it is necessary to terminate the workers after all analyses are complete. This is achieved by calling <code>scran.terminate()</code> once all operations are finished. Otherwise, the Node.js process will hang indefinitely as it waits for the workers to return. Browsers do not have this problem as the session ends when a user closes the relevant tab.</p>
<h2>k-means clustering</h2>
<p >For a faster alternative to the graph-based clustering algorithms, we can try using the k-means options instead. We perform k-means clustering on the PC matrix, so the output of <code>runPCA()</code> can be directly passed to the function. We need to specify the number of clusters - in this case, 20.</p>
<div class="fragment"><div class="line">let clustering = scran.clusterKmeans(pcs, 20);</div>
</div><!-- fragment --><p >We use PCA partitioning as the default initialization approach, which is more-or-less deterministic. However, advanced users can play around with other initialization methods and seeds:</p>
<div class="fragment"><div class="line">let clustpp = scran.clusterKmeans(pcs, 20, { initMethod: &quot;kmeans++&quot;, initSeed: 42 });</div>
</div><!-- fragment --><h2>Cell type classification</h2>
<p >We use the same algorithm as <b>SingleR</b> for cell type classification from reference datasets (available <a href="https://github.com/clusterfork/singlepp-references">here</a>). This assumes that we have several files describing each reference dataset:</p>
<ol type="1">
<li>A matrix of ranks as a Gzipped CSV file.</li>
<li>Markers from pairwise comparisons as a Gzipped GMT file.</li>
<li>Labels for each reference sample as a Gzipped CSV file.</li>
<li>Feature names for the matrix as a Gzipped CSV file.</li>
<li>Names for all labels as a Gzipped CSV file.</li>
</ol>
<p >Assuming the files have been downloaded and are available as <code>ArrayBuffer</code>s, we load the reference:</p>
<div class="fragment"><div class="line">let loaded = scran.loadLabelledReferenceFromBuffers(rankbuf, markbuf, labbuf); // files 1, 2 and 3, respectively.</div>
</div><!-- fragment --><p >We then build the reference given <code>testfeatures</code>, an array with the names of the features in our test dataset; and <code>reffeatures</code>, an array with the names of the features in our reference (extracted from file <b>4</b>). Note that <code>testfeatures</code> needs to be permuted to match the row order in our permuted matrix.</p>
<div class="fragment"><div class="line">let built = scran.buildLabelledReference(testfeatures, loaded, reffeatures);</div>
</div><!-- fragment --><p >Finally, we can generate labels from our input matrix. This returns indices that can be cross-referenced to the actual names of the labels in file <b>5</b>.</p>
<div class="fragment"><div class="line">let labels = scran.labelCells(mat, built);</div>
</div><!-- fragment --><p >For interactive use, we may prefer to generate per-cluster labels rather than per-cell labels, as the former is much faster. This is easily done by computing the cluster means, storing them in a dense array and passing that array to <code>labelCells</code>.</p>
<p >Advanced users can integrate cell labels from multiple references with the <code>integrateCells</code> function. See the <a href="https://github.com/jkanche/scran.js/blob/master/tests/labelCells.test.js">tests</a> for some working examples.</p>
<h1>Developer notes</h1>
<h2>Introducing WebAssembly</h2>
<p >We use WebAssembly (Wasm) to enable efficient client-side execution of common steps in a scRNA-seq analysis. Code to perform each step is written in C++ and compiled to Wasm using the <a href="https://emscripten.org/">Emscripten toolchain</a>. Some of the relevant C++ libraries are listed below:</p>
<ul>
<li><a href="https://github.com/LTLA/libscran">libscran</a> provides C++ implementations of key functions in <b>scran</b> and its fellow packages <b>scater</b> and <b>scuttle</b>. This includes quality control, normalization, feature selection, PCA, clustering and dimensionality reduction.</li>
<li><a href="https://github.com/LTLA/tatami">tatami</a> provides an abstract interface to different matrix classes, focusing on row and column extraction.</li>
<li><a href="https://github.com/LTLA/knncolle">knncolle</a> wraps a number of nearest neighbor detection methods in a consistent interface.</li>
<li><a href="https://github.com/LTLA/CppIrlba">CppIrlba</a> contains a C++ port of the IRLBA algorithm for approximate PCA.</li>
<li><a href="https://github.com/LTLA/CppKmeans">CppKmeans</a> contains C++ ports of the Hartigan-Wong and Lloyd algorithms for k-means clustering.</li>
<li><a href="https://github.com/LTLA/qdtsne">qdtsne</a> contains a refactored C++ implementation of the Barnes-Hut t-SNE dimensionality reduction algorithm.</li>
<li><a href="https://github.com/LTLA/umappp">umappp</a> contains a refactored C++ implementation of the UMAP dimensionality reduction algorithm.</li>
</ul>
<p >For each step, we use Emscripten to compile the associated C++ functions into Wasm and generate Javascript-visible bindings. We can then load the Wasm binary into a web application and call the desired functions on user-supplied data. Reference documentation for the Wasm bindings is available <a href="https://jkanche.github.io/scran.js/wasm">here</a>.</p>
<h2>Building the Wasm binary</h2>
<p >Make sure <a href="https://emscripten.org/docs/getting_started/downloads.html">Emscripten</a> and <a href="https://cmake.org/download/">CMake</a> are installed on your machine. Running the <code>build.sh</code> script will then generate ES6 and Node.js-compatible builds. To build the Node.js version:</p>
<div class="fragment"><div class="line">bash build.sh main</div>
</div><!-- fragment --><p >To build the ES6 version:</p>
<div class="fragment"><div class="line">bash build.sh module</div>
</div><!-- fragment --><p >This will create the <code>main</code> and <code>module</code> directories respectively, containing the Wasm file in the <code>wasm</code> subdirectory as well as copying all the relevant Javascript bindings.</p>
<h2>Tests</h2>
<p >Run the test suite by calling:</p>
<div class="fragment"><div class="line"># install dev dependencies</div>
<div class="line">npm install --include=dev</div>
<div class="line">npm run test</div>
</div><!-- fragment --><p >For earlier versions of Node, you may instead need to do some combination of the following options:</p>
<div class="fragment"><div class="line">node --experimental-vm-modules --experimental-wasm-threads --experimental-wasm-bulk-memory --experimental-wasm-bigint node_modules/jest/bin/jest.js</div>
</div><!-- fragment --><h1>Links</h1>
<p >Check out <a href="https://github.com/jkanche/kana">kana</a> to see how <b>scran.js</b> is used in an interactive scRNA-seq analysis application.</p>
<p >The <a href="https://github.com/LTLA/scran.chan"><b>scran.chan</b></a> R package and <a href="https://github.com/LTLA/scran-cli"><b>scran</b></a> executable are based on the same C++ libraries and allow the same analysis to be performed in different environments. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>

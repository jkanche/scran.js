<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>Single cell RNA-seq analysis in Javascript</h1>
<h2>Overview</h2>
<p>This repository contains <strong>scran.js</strong>, a Javascript library for single-cell RNA-seq (scRNA-seq) analysis in the browser.
The various calculations are performed directly by the client, allowing us to take advantage of the ubiquity of the browser as a standalone analysis platform.
Users can then directly analyze their data without needing to manage any dependencies or pay for access to a backend.
<strong>scran.js</strong> is heavily inspired by the <a href="https://bioconductor.org/packages/scran"><strong>scran</strong> R package</a> and contains most of its related methods.
Indeed, much of the implementation in this repository is taken directly from <strong>scran</strong> and its related R packages.</p>
<h2>Analysis overview</h2>
<p><strong>scran.js</strong> implements key steps in a typical scRNA-seq analysis:</p>
<ul>
<li>Quality control (QC) to remove low-quality cells.
This is done based on detection of outliers on QC metrics like the number of detected genes.</li>
<li>Normalization and log-transformation, to remove biases and mitigate the mean-variance trend.
We use scaling normalization with size factors defined from the library size for each cell.</li>
<li>Feature selection to identify highly variable genes.
This is based on residuals from a trend fitted to the means and variances of the log-normalized data for each gene.</li>
<li>Principal components analysis (PCA) on the highly variable genes, to compress and denoise the data.
We use an approximate method to quickly obtain the top few PCs.</li>
<li>Clustering on the cells using the top PCs.
This can either use k-means or multi-level community detection (a.k.a., &quot;Louvain clustering&quot;) on a shared nearest neighbor graph.</li>
<li>Dimensionality reduction with t-stochastic neighbor embedding (t-SNE), again using the top PCs.</li>
<li>Marker detection using a variety of effect sizes such as Cohen's d and the area under the curve (AUC).</li>
<li>Cell type annotation with a port of the <a href="https://bioconductor.org/packages/SingleR"><strong>SingleR</strong></a> algorithm.</li>
</ul>
<p>Coming soon:</p>
<ul>
<li>Batch correction via the mutual nearest neighbors method.</li>
</ul>
<p>The theory behind these methods is described in more detail in the <a href="https://bioconductor.org/books/release/OSCA/"><strong>Orchestrating Single Cell Analysis with Bioconductor</strong></a> book.
All steps are implemented in C++ and compiled to WebAssembly for near-native performance - see the <a href="#developer-notes">developer notes</a> for details.</p>
<h2>Quick start</h2>
<p><strong>scran.js</strong> is available as an <a href="https://www.npmjs.com/package/scran.js">npm package</a>, so installation can be performed via the usual procedure:</p>
<pre class="prettyprint source lang-sh"><code>npm install scran.js
</code></pre>
<p>Then you can import and initialize the library using the standard ES6 notation.
Before any actual analysis steps are performed, the <code>initialize()</code> function must be run and its promise resolved;
we suggest using a top-level <code>await</code> for convenience.</p>
<pre class="prettyprint source lang-js"><code>import * as scran from &quot;scran.js&quot;;
await scran.initialize({ numberOfThreads: 4 }); // for old Node versions, set localFile: true
</code></pre>
<p>After that, you can run the remaining steps synchronously - for example, using the Node.js API:</p>
<pre class="prettyprint source lang-js"><code>// Reading in the count matrix.
import * as fs from &quot;fs&quot;;
let buffer = fs.readFileSync(&quot;matrix.mtx.gz&quot;);
let mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);
</code></pre>
<p>Reference documentation for the Javascript API is available <a href="https://jkanche.github.io/scran.js">here</a>.</p>
<h2>Basic analyses</h2>
<p>The code chunk below implements a basic analysis, starting from count matrix loading and terminating at the markers for each cluster.
This uses the Node.js API to read in one of our example <a href="https://github.com/jkanche/random-test-files">Matrix Market files</a>,
but the same approach can be used on the buffer created from a <code>File</code> input in the browser.</p>
<pre class="prettyprint source lang-js"><code>// Reading in the count matrix.
import * as fs from &quot;fs&quot;;
let buffer = fs.readFileSync(&quot;matrix.mtx.gz&quot;);
let mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);

// Performing QC.
let qc_metrics = scran.computePerCellQCMetrics(mat, [ /* specify mito subset here */ ]);
let qc_thresholds = scran.computePerCellQCThresholds(qc_metrics);
let filtered = scran.filterCells(mat, qc_thresholds.discardOverall());

// Log-normalizing.
let normalized = scran.logNormCounts(filtered);

// Modelling per-gene variance and selecting top HVGs. 
let varmodel = scran.modelGeneVar(normalized);
let hvgs = scran.chooseHVGs(varmodel, { number: 4000 });

// Performing the PCA.
let pcs = scran.runPCA(normalized, { features: hvgs });

// Building the neighbor search index on the PCs.
let index = scran.buildNeighborSearchIndex(pcs);

// Performing the clustering. 
let cluster_graph = scran.buildSNNGraph(index, { neighbors: 10 });
let clustering = scran.clusterSNNGraph(cluster_graph);

// Performing the t-SNE and UMAP.
let tsne_status = scran.initializeTSNE(index);
let tsne_res = scran.runTSNE(tsne_status);

let umap_status = scran.initializeUMAP(index);
let umap_res = scran.runUMAP(umap_status);

// Detecting some markers.
let markers = scran.scoreMarkers(normalized, clustering.membership());
</code></pre>
<p>Note that the order of rows is permuted on input - see <a href="#permuting-the-row-order">below</a> for details.</p>
<h2>Further details</h2>
<h3>Permuting the row order</h3>
<p>Rows of the dataset are permuted by <code>initializeSparseMatrix*()</code> functions to achieve a memory-efficient layout in <code>mat</code>.
The permutation to restore the original row order can be obtained with:</p>
<pre class="prettyprint source lang-js"><code>let perm1 = mat.permutation();
</code></pre>
<p>This can be used to permute the results of per-gene analyses like <code>modelGeneVar()</code> and <code>scoreMarkers()</code> to match the original row order.
Alternatively, we can use:</p>
<pre class="prettyprint source lang-js"><code>let perm2 = mat.permutation({ restore: false });
</code></pre>
<p>if we want to permute something in the original order to match the row order of <code>mat</code>.</p>
<h3>Memory management</h3>
<p>All custom classes returned by <strong>scran.js</strong> functions refer to allocations on the Wasm heap and are not subject to garbage collection by Javascript.
If you intend to perform more <strong>scran.js</strong> operations after your analysis is complete, you will need to manually free existing objects to make space for new ones.
We suggest using the pattern below to catch all objects and free them.</p>
<pre class="prettyprint source lang-js"><code>var things = {};
things.mat = scran.initializeSparseMatrixFromMatrixMarketBuffer(buffer);

try {
    /** some work here, possibly adding more objects to 'things' **/
} finally {
    // Once the analysis is complete and results have been saved to file.
    for (const [key, val] of Object.entries(things)) {
        val.free();
    }
}
</code></pre>
<h3>Terminating workers</h3>
<p>On Node.js, it is necessary to terminate the workers after all analyses are complete.
This is achieved by calling <code>scran.terminate()</code> once all operations are finished.
Otherwise, the Node.js process will hang indefinitely as it waits for the workers to return.
Browsers do not have this problem as the session ends when a user closes the relevant tab.</p>
<h3>k-means clustering</h3>
<p>For a faster alternative to the graph-based clustering algorithms, we can try using the k-means options instead.
We perform k-means clustering on the PC matrix, so the output of <code>runPCA()</code> can be directly passed to the function.
We need to specify the number of clusters - in this case, 20.</p>
<pre class="prettyprint source lang-js"><code>let clustering = scran.clusterKmeans(pcs, 20);
</code></pre>
<p>We use PCA partitioning as the default initialization approach, which is more-or-less deterministic.
However, advanced users can play around with other initialization methods and seeds:</p>
<pre class="prettyprint source lang-js"><code>let clustpp = scran.clusterKmeans(pcs, 20, { initMethod: &quot;kmeans++&quot;, initSeed: 42 });
</code></pre>
<h3>Cell type classification</h3>
<p>We use the same algorithm as <strong>SingleR</strong> for cell type classification from reference datasets (available <a href="https://github.com/clusterfork/singlepp-references">here</a>).
This assumes that we have several files describing each reference dataset:</p>
<ol>
<li>A matrix of ranks as a Gzipped CSV file.</li>
<li>Markers from pairwise comparisons as a Gzipped GMT file.</li>
<li>Labels for each reference sample as a Gzipped CSV file.</li>
<li>Feature names for the matrix as a Gzipped CSV file.</li>
<li>Names for all labels as a Gzipped CSV file.</li>
</ol>
<p>Assuming the files have been downloaded and are available as <code>ArrayBuffer</code>s, we load the reference:</p>
<pre class="prettyprint source lang-js"><code>let loaded = scran.loadLabelledReferenceFromBuffers(rankbuf, markbuf, labbuf); // files 1, 2 and 3, respectively.
</code></pre>
<p>We then build the reference given <code>testfeatures</code>, an array with the names of the features in our test dataset;
and <code>reffeatures</code>, an array with the names of the features in our reference (extracted from file <strong>4</strong>).
Note that <code>testfeatures</code> needs to be permuted to match the row order in our permuted matrix.</p>
<pre class="prettyprint source lang-js"><code>let built = scran.buildLabelledReference(testfeatures, loaded, reffeatures);
</code></pre>
<p>Finally, we can generate labels from our input matrix.
This returns indices that can be cross-referenced to the actual names of the labels in file <strong>5</strong>.</p>
<pre class="prettyprint source lang-js"><code>let labels = scran.labelCells(mat, built);
</code></pre>
<p>For interactive use, we may prefer to generate per-cluster labels rather than per-cell labels, as the former is much faster.
This is easily done by computing the cluster means, storing them in a dense array and passing that array to <code>labelCells</code>.</p>
<p>Advanced users can integrate cell labels from multiple references with the <code>integrateCells</code> function.
See the <a href="https://github.com/jkanche/scran.js/blob/master/tests/labelCells.test.js">tests</a> for some working examples.</p>
<h2>Developer notes</h2>
<h3>Introducing WebAssembly</h3>
<p>We use WebAssembly (Wasm) to enable efficient client-side execution of common steps in a scRNA-seq analysis.
Code to perform each step is written in C++ and compiled to Wasm using the <a href="https://emscripten.org/">Emscripten toolchain</a>.
Some of the relevant C++ libraries are listed below:</p>
<ul>
<li><a href="https://github.com/LTLA/libscran">libscran</a> provides C++ implementations of key functions in <strong>scran</strong> and its fellow packages <strong>scater</strong> and <strong>scuttle</strong>.
This includes quality control, normalization, feature selection, PCA, clustering and dimensionality reduction.</li>
<li><a href="https://github.com/LTLA/tatami">tatami</a> provides an abstract interface to different matrix classes, focusing on row and column extraction.</li>
<li><a href="https://github.com/LTLA/knncolle">knncolle</a> wraps a number of nearest neighbor detection methods in a consistent interface.</li>
<li><a href="https://github.com/LTLA/CppIrlba">CppIrlba</a> contains a C++ port of the IRLBA algorithm for approximate PCA.</li>
<li><a href="https://github.com/LTLA/CppKmeans">CppKmeans</a> contains C++ ports of the Hartigan-Wong and Lloyd algorithms for k-means clustering.</li>
<li><a href="https://github.com/LTLA/qdtsne">qdtsne</a> contains a refactored C++ implementation of the Barnes-Hut t-SNE dimensionality reduction algorithm.</li>
<li><a href="https://github.com/LTLA/umappp">umappp</a> contains a refactored C++ implementation of the UMAP dimensionality reduction algorithm.</li>
</ul>
<p>For each step, we use Emscripten to compile the associated C++ functions into Wasm and generate Javascript-visible bindings.
We can then load the Wasm binary into a web application and call the desired functions on user-supplied data.
Reference documentation for the Wasm bindings is available <a href="https://jkanche.github.io/scran.js/wasm">here</a>.</p>
<h3>Building the Wasm binary</h3>
<p>Make sure <a href="https://emscripten.org/docs/getting_started/downloads.html">Emscripten</a> and <a href="https://cmake.org/download/">CMake</a> are installed on your machine.
Running the <code>build.sh</code> script will then generate ES6 and Node.js-compatible builds.
To build the Node.js version:</p>
<pre class="prettyprint source lang-sh"><code>bash build.sh main
</code></pre>
<p>To build the ES6 version:</p>
<pre class="prettyprint source lang-sh"><code>bash build.sh module
</code></pre>
<p>This will create the <code>main</code> and <code>module</code> directories respectively,
containing the Wasm file in the <code>wasm</code> subdirectory as well as copying all the relevant Javascript bindings.</p>
<h3>Tests</h3>
<p>Run the test suite by calling:</p>
<pre class="prettyprint source"><code># install dev dependencies
npm install --include=dev
npm run test
</code></pre>
<p>For earlier versions of Node, you may instead need to do some combination of the following options:</p>
<pre class="prettyprint source"><code>node --experimental-vm-modules --experimental-wasm-threads --experimental-wasm-bulk-memory --experimental-wasm-bigint node_modules/jest/bin/jest.js
</code></pre>
<h2>Links</h2>
<p>Check out <a href="https://github.com/jkanche/kana">kana</a> to see how <strong>scran.js</strong> is used in an interactive scRNA-seq analysis application.</p>
<p>The <a href="https://github.com/LTLA/scran.chan"><strong>scran.chan</strong></a> R package and <a href="https://github.com/LTLA/scran-cli"><strong>scran</strong></a> executable
are based on the same C++ libraries and allow the same analysis to be performed in different environments.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BuiltLabelledReference.html">BuiltLabelledReference</a></li><li><a href="H5Base.html">H5Base</a></li><li><a href="H5DataSet.html">H5DataSet</a></li><li><a href="H5File.html">H5File</a></li><li><a href="H5Group.html">H5Group</a></li><li><a href="IntegratedLabelledReferences.html">IntegratedLabelledReferences</a></li><li><a href="KmeansClusters.html">KmeansClusters</a></li><li><a href="LabelledReference.html">LabelledReference</a></li><li><a href="ModelGeneVarResults.html">ModelGeneVarResults</a></li><li><a href="NeighborSearchIndex.html">NeighborSearchIndex</a></li><li><a href="NeighborSearchResults.html">NeighborSearchResults</a></li><li><a href="PCAResults.html">PCAResults</a></li><li><a href="PerCellQCFilters.html">PerCellQCFilters</a></li><li><a href="PerCellQCMetrics.html">PerCellQCMetrics</a></li><li><a href="ScoreMarkersResults.html">ScoreMarkersResults</a></li><li><a href="ScranMatrix.html">ScranMatrix</a></li><li><a href="SNNGraph.html">SNNGraph</a></li><li><a href="SNNGraphMultilevelClusters.html">SNNGraphMultilevelClusters</a></li><li><a href="TSNEStatus.html">TSNEStatus</a></li><li><a href="UMAPStatus.html">UMAPStatus</a></li></ul><h3>Global</h3><ul><li><a href="global.html#buildLabelledReference">buildLabelledReference</a></li><li><a href="global.html#buildNeighborSearchIndex">buildNeighborSearchIndex</a></li><li><a href="global.html#buildSNNGraph">buildSNNGraph</a></li><li><a href="global.html#cbind">cbind</a></li><li><a href="global.html#cbindWithNames">cbindWithNames</a></li><li><a href="global.html#chooseHVGs">chooseHVGs</a></li><li><a href="global.html#clusterKmeans">clusterKmeans</a></li><li><a href="global.html#clusterSNNGraph">clusterSNNGraph</a></li><li><a href="global.html#computePerCellQCFilters">computePerCellQCFilters</a></li><li><a href="global.html#computePerCellQCMetrics">computePerCellQCMetrics</a></li><li><a href="global.html#createBigUint64WasmArray">createBigUint64WasmArray</a></li><li><a href="global.html#createFloat64WasmArray">createFloat64WasmArray</a></li><li><a href="global.html#createInt32WasmArray">createInt32WasmArray</a></li><li><a href="global.html#createNewHDF5File">createNewHDF5File</a></li><li><a href="global.html#createUint8WasmArray">createUint8WasmArray</a></li><li><a href="global.html#extractHDF5ObjectNames">extractHDF5ObjectNames</a></li><li><a href="global.html#fileExists">fileExists</a></li><li><a href="global.html#filterCells">filterCells</a></li><li><a href="global.html#findNearestNeighbors">findNearestNeighbors</a></li><li><a href="global.html#guessFeatures">guessFeatures</a></li><li><a href="global.html#heapSize">heapSize</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeDenseMatrixFromDenseArray">initializeDenseMatrixFromDenseArray</a></li><li><a href="global.html#initializeSparseMatrixFromCompressedVectors">initializeSparseMatrixFromCompressedVectors</a></li><li><a href="global.html#initializeSparseMatrixFromDenseArray">initializeSparseMatrixFromDenseArray</a></li><li><a href="global.html#initializeSparseMatrixFromHDF5">initializeSparseMatrixFromHDF5</a></li><li><a href="global.html#initializeSparseMatrixFromMatrixMarketBuffer">initializeSparseMatrixFromMatrixMarketBuffer</a></li><li><a href="global.html#initializeTSNE">initializeTSNE</a></li><li><a href="global.html#initializeUMAP">initializeUMAP</a></li><li><a href="global.html#integrateCellLabels">integrateCellLabels</a></li><li><a href="global.html#integrateLabelledReferences">integrateLabelledReferences</a></li><li><a href="global.html#labelCells">labelCells</a></li><li><a href="global.html#loadHDF5Dataset">loadHDF5Dataset</a></li><li><a href="global.html#loadLabelledReferenceFromBuffers">loadLabelledReferenceFromBuffers</a></li><li><a href="global.html#logNormCounts">logNormCounts</a></li><li><a href="global.html#mnnCorrect">mnnCorrect</a></li><li><a href="global.html#modelGeneVar">modelGeneVar</a></li><li><a href="global.html#permuteFeatures">permuteFeatures</a></li><li><a href="global.html#permuteVector">permuteVector</a></li><li><a href="global.html#perplexityToNeighbors">perplexityToNeighbors</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#removeFile">removeFile</a></li><li><a href="global.html#runPCA">runPCA</a></li><li><a href="global.html#runTSNE">runTSNE</a></li><li><a href="global.html#runUMAP">runUMAP</a></li><li><a href="global.html#scoreMarkers">scoreMarkers</a></li><li><a href="global.html#terminate">terminate</a></li><li><a href="global.html#unpermuteVector">unpermuteVector</a></li><li><a href="global.html#updatePermutation">updatePermutation</a></li><li><a href="global.html#wasmArraySpace">wasmArraySpace</a></li><li><a href="global.html#writeFile">writeFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Thu Mar 31 2022 06:26:50 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
import {ScranMatrix} from "./ScranMatrix.js";

/**
 * Permute a vector to match the row order of a {@linkplain ScranMatrix}.
 * This is usually applied to annotations that match the original row order,
 * but need to be permuted to be used in computation with a {@linkplain ScranMatrix}.
 *
 * @param {(ScranMatrix|Int32Array)} x - A {@linkplain ScranMatrix} where the rows are permuted for a more memory-efficient storage order.
 * Alternatively a permutation vector, generated by calling {@linkcode ScranMatrix#permutation permutation} with `restore: true` (the default).
 * @param {(Array|TypedArray)} values - An array of values where each entry corresponds to a row in the original row order.
 *
 * @return A copy of `values` is returned, permuted so that each entry corresponds to a row of `x`.
 */
export function permuteVector(x, values) {
    let copy = values.slice();

    let perm = null;
    if (x instanceof ScranMatrix) {
        if (x.isPermuted()) {
            perm = x.permutation({ copy: false });
        }
    } else {
        perm = x;
    }

    if (perm !== null) {
        perm.forEach((x, i) => {
            copy[x] = values[i];
        });
    }

    return copy;
}

/**
 * Unpermute a vector to match the original row order.
 * This is usually applied to per-feature results computed from a {@linkplain ScranMatrix}, 
 * to get results corresponding to the original row order.
 *
 * @param {(ScranMatrix|Int32Array)} x - A {@linkplain ScranMatrix} where the rows are permuted for a more memory-efficient storage order.
 * Alternatively a permutation vector, generated by calling {@linkcode ScranMatrix#permutation permutation} with `restore: true` (the default).
 * @param {(Array|TypedArray)} values - An array of values where each entry corresponds to a row of `x` (i.e., including the permutation).
 *
 * @return A copy of `values` is returned, permuted so that each entry corresponds to the original row order.
 */
export function unpermuteVector(x, values) {
    let copy = values.slice();

    let perm = null;
    if (x instanceof ScranMatrix) {
        if (x.isPermuted()) {
            perm = x.permutation({ copy: false });
        }
    } else {
        perm = x;
    }

    if (perm !== null) {
        perm.forEach((x, i) => {
            copy[i] = values[x];
        });
    }

    return copy;
}

/**
 * Compute a new permutation vector that modifies a vector to match the row order of a {@linkplain ScranMatrix}.
 * This is provided as a safety measure to handle changes in the permutation across different versions of the {@linkplain ScranMatrix} initialization.
 * The assumption is that there are some old results that are ordered to match the row order of an old version of a {@linkplain ScranMatrix}.
 * Given the old permutation vector, this function will enable applications to update their result vectors to match the row order of a new object.
 *
 * @param {(ScranMatrix|Int32Array)} x - A {@linkplain ScranMatrix} where the rows are permuted for a more memory-efficient storage order.
 * Alternatively a permutation vector, generated by calling {@linkcode ScranMatrix#permutation permutation} with `restore: true` (the default).
 * @param {TypedArray} old - A permutation vector for an older sparse matrix generated from the same dataset as `x`. 
 * This vector should have been created by calling {@linkcode ScranMatrix#permutation permutation} with `restore: true` (the default).
 *
 * @return `null` if the permutations are the same, in which case no further action is required.
 * Otherwise an `Int32Array` is returned containing a permutation that, when applied to a vector with {@linkcode permuteVector}, 
 * permutes that vector to match the row order of `x`.
 */
export function updatePermutation(x, old) {
    let spawnPerm = null;
    if (x instanceof ScranMatrix) {
        if (x.isPermuted()) {
            if (old.length != x.numberOfRows()) {
                throw "number of rows in 'x' should be the same as length of 'old'";
            }
            spawnPerm = () => x.permutation({ copy: false });
        }
    } else {
        if (old.length != x.length) {
            throw "length of 'x' should be the same as length of 'old'";
        }
        spawnPerm = () => x;
    }

    let same = true;
    if (spawnPerm !== null) {
        for (const [index, val] of spawnPerm().entries()) {
            if (old[index] != val) {
                same = false;
                break;
            }
        }
    }

    /* If spawnPerm = null, this means that 'x' has the original row order.
     * In that case, matching the row order of 'x' is as simple as just keeping
     * 'old' as it is, because it already aims to restore the original row order.
     */

    // No-op.
    if (same) {
        return null;
    }

    // Figure out which row in the old permutation gets the desired identity.
    // We respawn the permutation just in case there were any allocations.
    let output = old.slice();
    spawnPerm().forEach((x, i) => {
        output[x] = old[i];
    });
    return output;
}
